/**
 * JWT Verification Utility
 * 
 * This module handles offline JWT verification using a hardcoded public key.
 * It uses the jsrsasign library for RS256 signature verification.
 */

import {KJUR, KEYUTIL} from 'jsrsasign';
import { Buffer } from 'buffer';

// HARDCODED PUBLIC KEY - Generated by the Python script
const PUBLIC_KEY = `-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEArHQV7tTML4iEBOkL8Mv4
1VhA6Sbcf1R2w/CS+Q5/CYPlo7EMGqdxfjAYFF+k1XhYEw66jv8z4Cg+0QLkkyEJ
cCDfdPp5PuZ47wwqFKZV8IbbfkPBqGX0x/Ls+66k7jtIWXlGJi22LRtpMzScEdVj
IIBMLorxS9U5GtmwAyDGaNia2KHGNaGmpeiTX9G+5MT1c+XxUG5a9Au1EGJ+o+W6
eQUlgjeai5Li2bonBdpnXJqILmzLzvU5KbHMC51GiuBl1+nqd+ZTHNRcgEUc1AI/
QatRhB3Dl83GfJYIxk9yxjsiugviyuo12a81XqZHhf3KAh/d3Rr8d7ssa/SlV4ES
CQIDAQAB
-----END PUBLIC KEY-----`;

/**
 * Verify a JWT token using the hardcoded public key
 * @param {string} token - The JWT token to verify
 * @returns {Object} - Verification result with valid flag and payload/error
 */
export const verifyJWT = async (token) => {
  try {
    // Basic token format validation
    if (!token || typeof token !== 'string') {
      return {
        valid: false,
        error: 'Invalid token format',
      };
    }

    // Check if token has the correct JWT structure (3 parts separated by dots)
    const tokenParts = token.split('.');
    if (tokenParts.length !== 3) {
      return {
        valid: false,
        error: 'Invalid JWT structure',
      };
    }

    try {
      // Parse the public key
      const publicKey = KEYUTIL.getKey(PUBLIC_KEY);
      
      // Verify the JWT signature
      const isValid = KJUR.jws.JWS.verifyJWT(token, publicKey, {
        alg: ['RS256'],
      });

      if (!isValid) {
        return {
          valid: false,
          error: 'Invalid signature',
        };
      }

      // Decode the payload
      const payload = KJUR.jws.JWS.readSafeJSONString(
        Buffer.from(tokenParts[1], 'base64').toString()
      );

      // Validate required fields for new certificate structure
      const requiredFields = ['iss', 'iat', 'deviceID', 'deviceType', 'certificateID'];
      const missingFields = requiredFields.filter(field => !payload[field]);
      
      if (missingFields.length > 0) {
        return {
          valid: false,
          error: `Missing required fields: ${missingFields.join(', ')}`,
        };
      }

      // Additional validation
      const currentTime = Math.floor(Date.now() / 1000);
      
      // Check if certificate is not from the future (allow 5 minute clock skew)
      if (payload.iat > currentTime + 300) {
        return {
          valid: false,
          error: 'Certificate issued in the future',
        };
      }

      return {
        valid: true,
        payload: payload,
      };

    } catch (verificationError) {
      console.error('JWT verification error:', verificationError);
      return {
        valid: false,
        error: 'Signature verification failed',
      };
    }

  } catch (error) {
    console.error('JWT processing error:', error);
    return {
      valid: false,
      error: 'Failed to process certificate',
    };
  }
};

/**
 * Decode JWT payload without verification (for debugging)
 * @param {string} token - The JWT token to decode
 * @returns {Object} - Decoded payload or null
 */
export const decodeJWT = (token) => {
  try {
    const tokenParts = token.split('.');
    if (tokenParts.length !== 3) {
      return null;
    }

    const payload = JSON.parse(
      Buffer.from(tokenParts[1], 'base64').toString()
    );

    return payload;
  } catch (error) {
    console.error('JWT decode error:', error);
    return null;
  }
};

/**
 * Get certificate information for display
 * @param {Object} payload - Verified JWT payload
 * @returns {Object} - Formatted certificate information
 */
export const formatCertificateInfo = (payload) => {
  return {
    deviceID: payload.deviceID || 'Unknown',
    deviceType: payload.deviceType || 'Unknown Device',
    certificateID: payload.certificateID || 'N/A',
    issueTimestamp: payload.iat || 0,
    issuer: payload.iss || 'Unknown',
    dataHash: payload.dataHash || 'N/A',
  };
};